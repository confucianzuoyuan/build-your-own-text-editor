== 设置

啊, 第 1 步. 你不喜欢白纸一张的全新开始吗? 然后选择你将在其上建造整个富丽堂皇的庄园的那块奇异砖块?

不幸的是, 当你构建计算机程序时, 第 1 步可能会变得...复杂且令人沮丧. 你必须确保你的环境是为你正在使用的编程语言设置的, 并且你必须弄清楚如何在该环境中编译和运行你的程序.

幸运的是, 我们正在构建的程序不依赖于任何外部库, 因此除了 `C` 编译器和它附带的标准库之外, 你不需要任何东西(我们也将使用 `make` 程序). 要检查你是否安装了 `C` 编译器, 请尝试在命令行运行 `cc --version` (`cc` 代表 `C` 编译器). 要检查你是否有 `make` , 请尝试运行 `make -v`.

=== 如何安装 `C` 编译器...

==== 在 `Windows` 中

你将需要在 `Windows` 中安装某种 `Linux` 环境. 这是因为我们的文本编辑器使用头文件 `<termios.h>` 在底层与终端交互, 这在 `Windows` 上不可用. 我建议使用 `Windows` 上的 `Bash` 或 `Cygwin` .

**Bash on Windows**：仅适用于 `64` 位 `Windows 10` . 请参阅安装指南. 安装后, 只要想进入 `Linux` 环境就在命令行运行 `bash`. 在 `bash` 里面, 运行 `sudo apt-get install gcc make` 以安装 `GNU Compiler Collection` 和 `make` 程序. 如果 `sudo` 做任何事情都需要很长时间, 你可能需要修复 `/etc/hosts` 文件.

**Cygwin**：从 `cygwin.com/install.html` 下载安装程序. 当安装程序要求你选择要安装的包时, 查看类别 `devel` 并选择 `gcc-core` 和 `make` 包. 要使用 `Cygwin` , 你必须运行 `Cygwin` 终端程序. 与 `Windows` 上的 `Bash` 不同, 在 `Cygwin` 中, 你的主目录与 `Windows` 主目录是分开的. 如果你将 `Cygwin` 安装到 `C:\cygwin64` , 那么你的主目录位于 `C:\cygwin64\home\yourname` . 因此, 如果你想使用 `Cygwin` 之外的文本编辑器来编写你的代码, 那就是你要保存到的地方.

==== 在 `MacOS` 中

当你在终端尝试运行 `cc` 命令时, 会弹出一个窗口询问你是否要安装命令行开发人员工具. 你也可以运行 `xcode-select --install` 以弹出此窗口. 然后只需单击"安装", 它将安装 `C` 编译器和 `make`.

==== 在 `Linux` 中

在 `Ubuntu` 中, 它是 `sudo apt-get install gcc make`. 其他发行版也应该有 `gcc` 和 `make` 包可用.

==== 主函数 `main()`

创建一个名为的 `kilo.c` 的新文件, 并编写一个 `main()` 函数. (`kilo` 是我们正在构建的文本编辑器的名称.)

.第 1 步: kilo.c
[%linenums, c]
----
int main() {
  return 0;
}
----

在 `C` 中, 你必须将所有可执行代码放在函数中. `C` 中的函数 `main()` 比较特殊. 它是你运行程序时的默认起点. 当你 `return` 退出 `main()` 函数时, 程序退出并将返回的整数传递回操作系统. 返回值 `0` 表示成功.

`C` 是一种编译语言. 这意味着我们需要通过 `C` 编译器来编译我们的程序, 将其转换为可执行文件. 然后我们像在命令行上运行任何其他程序一样运行该可执行文件.

要编译 `kilo.c`, 在 `shell` 中运行 `cc kilo.c -o kilo` . 如果没有错误发生, 这将生成一个名为 `kilo` 的可执行程序. `-o` 代表"输出", 并指定输出可执行文件应命名为 `kilo` .

要运行 `kilo`, 请在 `shell` 中输入 `./kilo` 并按下回车键. 该程序不打印任何输出, 但你可以通过运行 `echo $?` 检查 `main()` 函数的退出状态, 也就是返回值, 这应该打印 `0`.

=== 使用 `make` 进行编译

每次你想重新编译时都要在终端中输入 `cc kilo.c -o kilo`, 这样很麻烦. 而 `make` 程序允许你只需要运行 `make`, 它就会编译你的程序. 你只需要提供一个 `Makefile` 文件来告诉它如何编译你的程序.

创建一个新文件 `Makefile`, `Makefile` 内容如下.

.第 2 步: Makefile
[%linenums, Makefile]
----
kilo: kilo.c
	$(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99
----

第 1 行表示我们要构建的是 `kilo`, 而 `kilo.c` 就是构建它所需要的. 第 2 行指定要运行的命令, 以便实际使用 `kilo.c` 来构建 `kilo`. 第 2 行的缩进, 确保使用 **制表符** 而不是空格. 你可以根据需要缩进 `C` 语言代码, 但是 `Makefile` 必须使用制表符.

我们在编译命令中添加了一些东西：

- `$(CC)` 是一个 `make` 会展开的变量, 默认是 `cc`.
- `-Wall` 代表"所有警告", 并让编译器在看到程序中的代码时向你发出警告, 这些代码在技术上可能没有错误, 但被认为是 `C` 语言的错误或有问题的用法, 例如在初始化变量之前使用变量.
- `-Wextra` 和 `-pedantic` 会打开更多警告. 对于本教程中的每个步骤, 如果你的程序能够编译通过, 除了在某些情况下出现"未使用的变量"警告外, 它不应产生任何警告. 如果你收到任何其他警告, 请检查以确保你的代码与该步骤中的代码完全匹配.
- `-std=c99` 指定我们正在使用的 `C` 语言标准的确切版本, 即 `C99`. `C99` 允许我们在函数内的任何地方声明变量, 而 `ANSI C` 要求所有变量都在函数或块的顶部声明.

现在我们有了一个 `Makefile`, 试着运行 `make` 编译程序.

它可能会输出 `make: 'kilo' is up to date.`. 它可以通过查看每个文件的最后修改时间戳来判断当前版本 `kilo.c` 是否已经编译. 如果 `kilo` 在 `kilo.c` **last modified** 之后也 **last modified**了, 则 `make` 假定 `kilo.c` 已经编译, 因此它不会运行编译命令. 如果 `kilo.c` 的 **last modified** 是在 `kilo` 的 **last modified** 之后, 则 `make` 重新编译 `kilo.c`. 这对于需要编译许多不同组件的大型项目更有用, 因为当你只对一个组件的源代码进行更改时, 大多数组件不需要一遍又一遍地重新编译.

尝试将返回值更改为 `kilo.c` 以外的数字 `0` . 然后运行 `make`, 你应该会看到它已编译. 运行 `./kilo`, 并尝试 `echo $?` 查看是否获得更改后的数字. 然后改回 `0`, 重新编译, 确保它变回 `return 0`.

在本教程中的每个步骤之后, 你都需要重新编译 `kilo.c`, 看看它是否在你的代码中发现任何错误, 然后运行 `./kilo`. 我们很容易忘记重新编译而直接运行 `./kilo`, 然后发现为什么你的更改 `kilo.c` 似乎没有任何效果. 你必须重新编译才能使 `kilo.c` 中的更改反映在 `kilo` 里面.

在下一章中, 我们将努力让终端进入原始模式, 并读取用户的各个按键. 